---
layout: post
title: SOLID паттерны в виде таблицы
category: software architecture
tags: [design patterns, development]
---

Источник: блог Сергея Теплякова.

# Single responsibility

**Anti-SRP**: Чрезмерная любовь к SRP ведет к обилию мелких классов, и в итоге логика размывается между ними.

**Зачем**: Борьба со сложностью

**Объяснение**: У каждого класса должна быть одна причина для изменения

**Пример нарушения:**
1. WCF - бизнес-логика смешана со способом репрезентации.
2. Некий класс, который парсит json-строку и анализирует его
___

# The Open-Closed

**Anti-SRP**: Можно получить фабрику-фабрик и излишние уровни абстракции.

**Зачем**: Ограничить изменение максимально минимальным кол-вом модулей/классов.

**Объяснение**: Программные сущности должны быть открыты для расширения, но закрыты для модификации.

Закрытость - стабильность интерфейсов. Открытость - возможность переопределять в дочерних классах логику или изменять реализацию интерфейсов.
Пример нарушения: Размазывание информации об иерархии типов по всему проекту.
___

# Liskov Subtitution

**Anti-SRP**: Либо слишком много наследования, либо полное его отсутствие

**Зачем**: Реализовать подтипы правильно

**Объяснение**: Должна быть возможность подставить вместо базового типа любой его подтип.

Для корректной реализации отношения "Является" подтип может ослаблять предусловия и усиливать постусловия (требовать меньше и гарантировать больше), при этом инварианты базового класса должны выполняться наследником. В противном случае такой нарушающий наследник может привести к непредвиденному поведению.
___

# Interface Segregation

**Anti-SRP**: Слишком много интерфейсов с размазанной логикой

**Зачем**: Предоставление удобного интерфейса вне зависимости от клиентов

**Объяснение**: Клиенты не должны вынужденно зависеть от методов, которыми они не пользуются.

Интерфейс должен быть согласованным вне зависимости от числа его клиентов. Иначе могут появляться схожие методы по смыслу, но которые используются разными клиентами.

__

# Dependency Inversion

**Anti-SRP**: Интерфейс под каждый класс, милилион параметров конструктора.

**Зачем**: Сделать ключевые/изменчивые зависимости более явными

**Объяснение**: Модули верхнего уровня не должны зависеть от модулей нижнего уровня; и те, и другие должны зависеть от абстракций.

Слишком много зависимостей класса говорит об его чрезмерной сложности. Любой объектный дизайн - граф взаимодействующих объектов, которые создаются в нем (композиция) или передаются извне (агрегация). Выделять зависимости полезно, когда зависимость изменчива и реализует "стратегию".
Пример нарушения: Синглтон, сервис-локатор.

